name: Auto Build on ELRS Release

on:
  schedule:
    - cron: '0 6 * * *'
  workflow_dispatch:

env:
  UPSTREAM_REPO: ExpressLRS/ExpressLRS
  REGULATORY_DOMAIN: -DRegulatory_Domain_US_433_WIDE
  MODULE_NAME: RFM96
  BAND_NAME: US433W

jobs:
  check-and-build:
    runs-on: ubuntu-latest

    steps:
      - name: Get latest ELRS release
        id: elrs_release
        run: |
          RELEASE_DATA=$(curl -s https://api.github.com/repos/${{ env.UPSTREAM_REPO }}/releases/latest)
          TAG=$(echo "$RELEASE_DATA" | jq -r '.tag_name')
          PUBLISHED=$(echo "$RELEASE_DATA" | jq -r '.published_at')
          PRERELEASE=$(echo "$RELEASE_DATA" | jq -r '.prerelease')
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "published=$PUBLISHED" >> $GITHUB_OUTPUT
          echo "prerelease=$PRERELEASE" >> $GITHUB_OUTPUT

      - name: Check if stable and older than 7 days
        id: check_age
        run: |
          if [ "${{ steps.elrs_release.outputs.prerelease }}" == "true" ]; then
            echo "should_build=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          PUBLISHED="${{ steps.elrs_release.outputs.published }}"
          PUBLISHED_TS=$(date -d "$PUBLISHED" +%s)
          NOW_TS=$(date +%s)
          AGE_DAYS=$(( (NOW_TS - PUBLISHED_TS) / 86400 ))
          if [ $AGE_DAYS -lt 7 ]; then
            echo "should_build=false" >> $GITHUB_OUTPUT
          else
            echo "should_build=true" >> $GITHUB_OUTPUT
          fi

      - name: Check if already built
        id: check_built
        if: steps.check_age.outputs.should_build == 'true'
        run: |
          TAG="${{ steps.elrs_release.outputs.tag }}"
          MY_RELEASE="ELRS_${TAG}_${{ env.MODULE_NAME }}_${{ env.BAND_NAME }}"
          EXISTING=$(curl -s -o /dev/null -w "%{http_code}" \
            https://api.github.com/repos/${{ github.repository }}/releases/tags/$MY_RELEASE)
          if [ "$EXISTING" == "200" ]; then
            echo "should_build=false" >> $GITHUB_OUTPUT
          else
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "release_tag=$MY_RELEASE" >> $GITHUB_OUTPUT
          fi

      - name: Checkout upstream ELRS
        if: steps.check_built.outputs.should_build == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.UPSTREAM_REPO }}
          ref: ${{ steps.elrs_release.outputs.tag }}
          submodules: recursive

      - name: Set up Python
        if: steps.check_built.outputs.should_build == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install PlatformIO
        if: steps.check_built.outputs.should_build == 'true'
        run: pip install platformio intelhex

      - name: Create hardware layout files
        if: steps.check_built.outputs.should_build == 'true'
        run: |
          mkdir -p src/hardware
          cat > src/hardware/ESP32C3_SuperMini_RX.json << 'EOF'
          {
              "platform": "esp32-c3",
              "product_name": "DIY ESP32-C3 SuperMini RX (RFM96)",
              "serial_rx": 20,
              "serial_tx": 21,
              "radio_dio0": 1,
              "radio_dio1": 2,
              "radio_miso": 5,
              "radio_mosi": 4,
              "radio_nss": 7,
              "radio_rst": 3,
              "radio_sck": 6,
              "power_min": 0,
              "power_high": 2,
              "power_max": 2,
              "power_default": 2,
              "power_control": 0,
              "power_values": [120, 124, 127],
              "led": 8
          }
          EOF
          cp src/hardware/ESP32C3_SuperMini_RX.json .

      - name: Configure build
        if: steps.check_built.outputs.should_build == 'true'
        working-directory: src
        run: |
          sed -i 's/^-DRegulatory_Domain_.*/#&/' user_defines.txt
          echo "${{ env.REGULATORY_DOMAIN }}" >> user_defines.txt
          echo "-DLOCK_ON_FIRST_CONNECTION" >> user_defines.txt
          echo "-DAUTO_WIFI_ON_INTERVAL=60" >> user_defines.txt

      - name: Build RX firmware (ESP32-C3)
        if: steps.check_built.outputs.should_build == 'true'
        working-directory: src
        run: |
          pio run -e Unified_ESP32C3_900_RX_via_UART
          cp .pio/build/Unified_ESP32C3_900_RX_via_UART/firmware.bin \
             ../ELRS_${{ steps.elrs_release.outputs.tag }}_RX_ESP32C3_${{ env.MODULE_NAME }}_${{ env.BAND_NAME }}.bin
          cp .pio/build/Unified_ESP32C3_900_RX_via_UART/bootloader.bin ../bootloader_rx.bin
          cp .pio/build/Unified_ESP32C3_900_RX_via_UART/partitions.bin ../partitions_rx.bin
          cp .pio/build/Unified_ESP32C3_900_RX_via_UART/boot_app0.bin ../boot_app0_rx.bin

      - name: Create Release
        if: steps.check_built.outputs.should_build == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.check_built.outputs.release_tag }}
          name: "ELRS ${{ steps.elrs_release.outputs.tag }} RX for ${{ env.MODULE_NAME }} (${{ env.BAND_NAME }})"
          body: |
            ## Auto-built from ELRS ${{ steps.elrs_release.outputs.tag }}

            RX firmware for ${{ env.MODULE_NAME }} module (SX1276, +20dBm/100mW).

            ### Hardware
            - **RX:** ESP32-C3 SuperMini + ${{ env.MODULE_NAME }}

            ### Frequency
            - Band: ${{ env.BAND_NAME }} (423.5-438MHz, 20 channels)

            ### Compatibility
            Works with TX using E32-400M30S module (same band).

            ### Flashing RX (ESP32-C3)
            ```bash
            esptool.py --chip esp32c3 write_flash \
                0x0 bootloader_rx.bin \
                0x8000 partitions_rx.bin \
                0xe000 boot_app0_rx.bin \
                0x10000 ELRS_*_RX_ESP32C3_*.bin
            ```

            ---
            *Auto-built by GitHub Actions*
          files: |
            bootloader_rx.bin
            partitions_rx.bin
            boot_app0_rx.bin
            ELRS_${{ steps.elrs_release.outputs.tag }}_RX_ESP32C3_${{ env.MODULE_NAME }}_${{ env.BAND_NAME }}.bin
            ESP32C3_SuperMini_RX.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
